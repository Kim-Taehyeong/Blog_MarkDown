---
created : 2024-03-01 10:29:46.417734
title : 백준 15658 연산자 끼워넣기 (2)
tag : [백트래킹 ,완전탐색]
author : taehyeok
category : algorithm
---
# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/9.svg" width="30" height="40"> 백준 15658 연산자 끼워넣기 (2)


### 풀이 언어 : C++

문제 구분 : #백트래킹 #완전탐색
#### [LINK - 백준 15658 연산자 끼워넣기 (2)](https://www.acmicpc.net/problem/15658)

### 문제

<hr>


N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다. 연산자의 개수는 N-1보다 많을 수도 있다. 모든 수의 사이에는 연산자를 한 개 끼워넣어야 하며, 주어진 연산자를 모두 사용하지 않고 모든 수의 사이에 연산자를 끼워넣을 수도 있다.

우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.

예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 3개, 뺄셈(-) 2개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 250가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다.

- 1+2+3-4×5÷6
- 1÷2+3+4-5×6
- 1+2÷3×4-5+6
- 1÷2×3-4+5+6
- 1+2+3+4-5-6
- 1+2+3-4-5×6

식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 음수를 양수로 나눌 때는 C++14의 기준을 따른다. 즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.

- 1+2+3-4×5÷6 = 1
- 1÷2+3+4-5×6 = 12
- 1+2÷3×4-5+6 = 5
- 1÷2×3-4+5+6 = 7
- 1+2+3+4-5-6 = -1
- 1+2+3-4-5×6 = -18

N개의 수와 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.

### 입력

<hr>


첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 100) 셋째 줄에는 합이 N-1보다 크거나 같고, 4N보다 작거나 같은 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다. 
### 출력

<hr>


첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다. 연산자를 어떻게 끼워넣어도 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 또한, 앞에서부터 계산했을 때, 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.
### 풀이 이야기

<hr>


이 문제는 [14888 연산자 끼워넣기](./14888.md) 문제와 매우 유사하다. 다른 점은 연산자의 개수의 차이일 뿐인데, 사실상 핵심 풀이 방식은 동일하다고 보아도 된다.

간략히 설명하자면, 4가지 연산자가 존재하는 경우에 백트래킹을 실시하는 조건으로 재귀호출을 지속적으로 실행하면된다. 여기서 기저 사례의 경우 N개의 연산자를 사용하는 경우 식이 완성된 것이기 때문에 해당 지점에서 최소값과 최대값을 업데이트하면 풀이할 수 있다. 자세한 설명은 코드 주석을 활용하자.

### 풀이 코드

<hr>


``` c++
#include <iostream>
#include <vector>

int op[4]; // + - * /
int N;
int m = 2147483647;
int M = -2147483648;
std::vector<int> v;

// Solve
void solve(int depth, int calc) {
    // 기저 사례 : N 개의 연산자를 선택한 경우
    if (depth == N) {
        // M, m 업데이트
        M = std::max(M, calc);
        m = std::min(m, calc);
        return ;
    }
    // + 연산
    if (op[0]) {
        op[0]--;
        solve(depth + 1, calc + v[depth]);
        op[0]++;
    }
    // - 연산
    if (op[1]) {
        op[1]--;
        solve(depth + 1, calc - v[depth]);
        op[1]++;
    }
    // * 연산
    if (op[2]) {
        op[2]--;
        solve(depth + 1, calc * v[depth]);
        op[2]++;
    }
    // / 연산
    if (op[3]) {
        op[3]--;
        solve(depth + 1, calc / v[depth]);
        op[3]++;
    }
}

int main(void) {
    // Input
    std::cin >> N;
    for (int i = 0; i < N; i++) {
        int tmp;
        std::cin >> tmp;
        v.push_back(tmp);
    }
    for (int i = 0; i < 4; i++) {
        int tmp;
        std::cin >> tmp;
        op[i] = tmp;
    }
    // Solve
    solve(1, v[0]);
    // Print
    std::cout << M << std::endl;
    std::cout << m << std::endl;
}
```
