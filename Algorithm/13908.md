
# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/9.svg" width="30" height="40"> 백준 13908 비밀번호


### 풀이 언어 : C++

문제 구분 : #백트래킹 #완전탐색
#### [LINK - 백준 13908 비밀번호](https://www.acmicpc.net/problem/13908)

### 문제
<hr>

웅찬이는 근성이 대단한 도둑이다. 그래서 금고를 털 때, 모든 조합을 눌러본다. 예를 들어 비밀번호가 3글자 라는 사실을 알 때, 000, 001, 002, 003, … 998, 999의 모든 조합을 눌러본다. 그러나 웅찬이는 선견지명이 있어서 비밀번호에 어떤 숫자가 들어가는지 일부 알 수 있다. 예를 들어 3글자 비밀번호에 0이 들어감을 안다면 999 와 같이 0이 들어가지 않는 수는 가능성이 없다. 그러나 000, 012, 030과 같은 수는 가능하다. 비밀번호의 길이와 선견지명으로 알게된 비밀번호의 일부 숫자가 주어질 때, 모든 가능한 비밀번호의 개수를 출력하는 프로그램을 작성하시오.

### 입력
<hr>

첫줄에 비밀번호의 길이 n (1 ≤ n ≤ 7), 선견지명으로 알게된 비밀번호에 들어가는 수 m(0 ≤ m ≤ n) 이 주어지고, 둘째 줄에 m개의 서로 다른 숫자(0~9)가 주어진다. m이 0인 경우 둘째 줄은 주어지지 않는다.
### 출력
<hr>
가능한 모든 비밀번호의 개수를 출력한다.

### 풀이 이야기
<hr>

이 문제는 모든 비밀번호를 백트래킹을 통해서 구하면 되는데, 조건이 하나 달려있다. 알게된 비밀번호 숫자를 활용해서 경우의 수를 획기적으로 줄일 수 있다는 가정을 주었다. 따라서 기본적인 백트래킹과 같이 기저사례를 두어 재귀 호출로 풀이할 수 있고, 기저 사례들을 보면서 풀이의 감을 익힐 수 있다.

1. M 개의 알게된 비밀번호를 사용 안한 경우
2. N 개의 숫자를 모두 선택한 경우

위 기저 사례를 보면 2번의 경우는 기본적인 백트래킹과 동일하다. 단순히 N자리의 비밀번호 숫자를 선택하면 그만 두는 것, 문제 풀이의 근본이다. 다만 1번 조건은 이번 M개의 미리 알게된 조건 때문에 생긴 기저사례이다. 관련 조건 코드를 보면 조금 더 쉽게 이해할 수 있다.
```c++
    if (N - passSize < depth - size)
        return ;
```
위 코드가 1번 기저사례에 해당하는 코드이다. `passSize`는 미리 알게된 숫자 개수 `M`과 같다. `depth`는 현재 까지 고른 숫자의 수 이고, `size`는 현재까지 고른 숫자 중에서 `미리 알게된 숫자`의 수를 말한다. 따라서 `N - passSize`는 미리 알게된 숫자를 제외하고 뽑을 수 있는 숫자의 수를 뜻하고, `depth - size`는 현재 미리 알게된 숫자를 제외하고 뽑은 숫자를 의미한다. 따라서 미리 알게된 숫자를 사용하지 않고 뽑은 경우를 자연스럽게 걸러낼 수 있게하는 기저사례인 것이다.

이번 문제에서는 핵심 키워드인 `기저사례 1번`을 이해한다면 단순한 백트래킹 순열 구하기에서 약간의 변형이 된 문제이다. 만약 백트래킹 자체가 익숙하지 않다면, 다른 쉬운 백트래킹 문제로 백트래킹에 대해서 익혀보자.

### 풀이 코드
<hr>

``` c++
#include <iostream>

int N, M, ret, passSize;
bool pass[10]; // 0 ~ 9 중 

void solve(int depth, int size) {
    // 기저 사례 1 : M 개의 알게된 비밀번호를 사용 안한 경우 Ret
    if (N - passSize < depth - size)
        return ;
    // 기저 사례 2 : N 개의 숫자를 모두 뽑은 경우
    if (depth == N) {
        ret += 1; // ret + 1
        return ;
    }
    // 0 ~ 9 까지 숫자 선택
    for (int i = 0; i <= 9; i++) {
        // 알게된 비밀번호 인 경우
        if (pass[i]) {
            pass[i] = false; // 사용 체킹
            solve(depth + 1, size + 1); // 재귀 호출
            pass[i] = true; // 사용 원복
        }
        else // 아닌 경우
            solve(depth + 1, size);
    }
}

int main(void) {
    // Input
    std::cin >> N >> M;
    for (int i = 0; i < M; i++) {
        int tmp;
        std::cin >> tmp;
        pass[tmp] = true;
        passSize += 1;
    }
    // Solve
    solve(0, 0);
    // Print
    std::cout << ret << std::endl;
}
```
