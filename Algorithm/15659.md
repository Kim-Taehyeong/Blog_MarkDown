
# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/12.svg" width="30" height="40"> 백준 15659 연산자 끼워넣기 (3)


문제 구분 : #백트래킹 #완전탐색
#### [LINK - 백준 15659 연산자 끼워넣기 (3)](https://www.acmicpc.net/problem/15659)

### 문제
<hr>

N개의 수로 이루어진 수열 $A_1$, $A_2$, ..., $A_N$이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.

우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.

예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 60가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다.

- 1+2+3-4×5÷6
- 1÷2+3+4-5×6
- 1+2÷3×4-5+6
- 1÷2×3-4+5+6

식의 계산은 연산자 우선 순위를 이용해 계산해야 한다. 연산자 우선 순위는 ×와 ÷가 +와 -보다 앞선다. 우선 순위가 같은 경우에는 앞에 있는 식을 먼저 계산한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.

- 1+2+3-4×5÷6 = 3
- 1÷2+3+4-5×6 = -23
- 1+2÷3×4-5+6 = 2
- 1÷2×3-4+5+6 = 7

N개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.

### 입력
<hr>

첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 둘째 줄에는 $A_1$, $A_2$, ..., $A_N$이 주어진다. (1 ≤ $A_i$ ≤ 100) 셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다.

### 출력
<hr>

첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다. 최댓값과 최솟값이 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 또한, 식을 어떤 순서로 계산해도 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.

### 풀이 이야기
<hr>

문제 풀이 과정에서 고민도 많이하고 방향을 잘못 잡아 여러번 다시 코드를 작성했다. 처음에는 각각의 계산을 우선순위를 고려해서 연산하기 위해서 후위 연산식으로 변경하고 이를 다시 후위 연산에 따른 연산 우선순위 계산을 진행하려고 했는데 불필요한 코드가 너무 많아지는 탓에 다른 방식으로 변경하자가고 마음 먹었다.

실제로 이 문제에서는 괄호가 존재하지 않기 때문에 그냥 탐색으로만으로도 연산자 우선순위를 구현할 수 있었다. 이에 수식에서 `*`, `/` 연산만을 먼저 찾아 연산을 진행하고 이후 `+`, `-`을 진행하면 된다.

이전 [연산자 끼워넣기](./14888.md)와 기본적인 백트래킹 탐색 기법은 동일하다. 다만 연산자의 우선순위를 고려해야하는 점이 차이가 있다. 따라서 이전에 사용했던 완전 탐색을 통해 탐색한 뒤에 식이 완성 되었을 때 식의 최대, 최소를 평가하고 업데이트하는 형식으로 구현했다.

#### 우선순위에 따라 식을 평가하는 법
1. 먼저 앞서 설명한 대로 `*`, `/` 수식을 먼저 연산한다. 이 수식을 연산하기 위해서 operator들이 들어있는 `coper` 에서 `*`, `/`를 찾는다. 
2. `std::find` 연산을 통해서 두 문자를 찾을 때, 둘 중 더 작은 iter 값을 가지고 있는 iter를 사용한다. (같은 우선순위라면 수식은 앞에서 부터 연산해야한다.)
3. `*`, `/`연산자를 구분하여 숫자가 들어있는 `v` 배열의 index를 활용해 연산을 진행한다. (`*`가 1번째에 존재한다면 `v`의 1, 2번째를 곱하면 된다. `v`의 크기는 항상 `coper`보다 1만큼 크다.)
4. 연산에 사용된 숫자 중 1개와 연산자는 `erase`메소드로 삭제한다.
5. 다시 1로 돌아가 `*`, `/`가 없을 때 까지 반복한다.
6. `coper`에 더 이상 연산자가 없을 때 까지 `+`, `-` 연산을 순차적으로 진행한다.
7. 마지막으로 남은 `v`의 숫자가 바로 연산의 결과이다.

🚨**주의해야할 점**
>**Q1. Deque를 사용한 이유는 무엇인가요?**  
>**A1.** Deque를 사용한 이유는 Erase연산의 시간복잡도를 줄이기 위해서 사용했다. 우선순위에 따라 식을 평가할 때 우리는 Erase연산을 진행한다. `vector`를 사용하는 경우 맨 뒤에 있는 요소를 제외하고는 O(N)의 크기의 시간복잡도가 걸린다. 따라서 덧셈, 뺄셈 연산을 할 때 맨 앞의 요소 삭제를 더 빠르게 하기 위해서 Deque를 선택했다. 사실 곱셈, 나눗셈 연산처럼 요소 중간의 삭제 시간까지 고려한다면, List 자료형을 사용하는게 가장 최적의 경우일 것이다.

### 풀이 코드
<hr>

``` c++
#include <iostream>
#include <deque>
#include <algorithm>

// 입력 출력 변수
int N, m = 2147483647;
int M = -2147483648;
std::deque<int> v; // 입력 숫자 배열
std::deque<int> oper; // 각 연산자 개수 + - * /
std::deque<char> coper; // 현재 만든 연산자 순서

int calc() {
    // v, coper 복사 진행 (삭제가 필요하기 때문에 복사해야 함)
    std::deque<int> b(v);
    std::deque<char> o(coper);
    // *, / 연산자 중 더 먼저나오는 연산자 찾기
    auto it = std::min(std::find(o.begin(), o.end(), '*'), std::find(o.begin(), o.end(), '/'));
    // 연산자를 못찾을 때 까지 반복
    while (it != o.end()) {
        // index 계산
        int idx = std::distance(o.begin(), it);
        // * 연산자면 * 연산 진행
        if (o[idx] == '*')
            b[idx] = b[idx] * b[idx + 1];
        else // 아니면 / 연산 진행
            b[idx] = b[idx] / b[idx + 1];
        // 사용한 연산자 및 숫자 1개 씩 삭제
        b.erase(b.begin() + idx + 1);
        o.erase(o.begin() + idx);
        // 다음 검색
        it = std::min(std::find(o.begin(), o.end(), '*'), std::find(o.begin(), o.end(), '/'));
    }
    // 연산자를 모두 소진할 때 까지
    while (o.size()) {
        if (o[0] == '+') // + 라면 + 연산 진행
            b[1] = b[0] + b[1];
        else // - 라면 - 연산 진행
            b[1] = b[0] - b[1];
        // 사용한 연산자 및 숫자 1개 씩 삭제 (첫 요소 제거로 인한 Deque 이점 활용)
        o.pop_front();
        b.pop_front();
    }
    return b.back(); // 남은 요소 Ret
}

// Solve
void solve(int depth) {
    // 모든 연산자를 선택했다면
    if (depth == N - 1) {
        int ret = calc(); // 연산 진행
        // 값 업데이트
        M = std::max(M, ret);
        m = std::min(m, ret);
        return ;
    }
    if (oper[0]) { // + 연산자가 남았다면
        coper.push_back('+');
        oper[0] -= 1;
        solve(depth + 1);
        coper.pop_back();
        oper[0] += 1;
    }
    if (oper[1]) { // - 연산자가 남았다면
        coper.push_back('-');
        oper[1] -= 1;
        solve(depth + 1);
        coper.pop_back();
        oper[1] += 1;
    }
    if (oper[2]) { // * 연산자가 남았다면
        coper.push_back('*');
        oper[2] -= 1;
        solve(depth + 1);
        coper.pop_back();
        oper[2] += 1;
    }
    if (oper[3]) { // / 연산자가 남았다면
        coper.push_back('/');
        oper[3] -= 1;
        solve(depth + 1);
        coper.pop_back();
        oper[3] += 1;
    }
}

int main(void) {
    // Input
    std::cin >> N;
    for (int i = 0; i < N; i++) {
        int tmp;
        std::cin >> tmp;
        v.push_back(tmp);
    }
    for (int i = 0; i < 4; i++) {
        int tmp;
        std::cin >> tmp;
        oper.push_back(tmp);
    }
    // Solve
    solve(0);
    // Print
    std::cout << M << std::endl << m << std::endl;
}
```
