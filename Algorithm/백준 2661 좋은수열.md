문제 구분 : #백트래킹 #완전탐색 
##### [문제 - 백준 2661 좋은 수열](https://www.acmicpc.net/problem/2661)

### 문제
<hr>

숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다. 그렇지 않은 수열은 좋은 수열이다. 다음은 나쁜 수열의 예
이다.
- 33
- 32121323
- 123123213
다음은 좋은 수열의 예이다.
- 2
- 32
- 32123
- 1232123
길이가 N인 좋은 수열들을 N자리의 정수로 보아 그중 가장 작은 수를 나타내는 수열을 구하는 프로그램을 작성하라. 예를 들면, 1213121과 2123212는 모두 좋은 수열이지만 그 중에서 작은 수를 나타내는 수열은 1213121이다.
### 입력
<hr>

입력은 숫자 N하나로 이루어진다. N은 1 이상 80 이하이다.
### 출력
<hr>

첫 번째 줄에 1, 2, 3으로만 이루어져 있는 길이가 N인 좋은 수열들 중에서 가장 작은 수를 나타내는 수열만 출력한다. 수열을 이루는 1, 2, 3들 사이에는 빈칸을 두지 않는다.
### 풀이 이야기
<hr>

이 문제는 단순 백트래킹을 활용하긴 하지만, 문제에 대한 규칙을 찾는 것이 중요한 문제이다. 각 지점에서 좋은 수열인지 나쁜 수열인지 판단하면서 현재 선택한 숫자가 규칙을 깨진 않는지 잘 검사해야한다. 중요한 점은 이 규칙이 어떨 때 깨지는 지를 판단해야한다. 만약 현재 N개의 숫자를 만들었다면, 여기서 만들 수 있는 가장 긴 2개의 수열은 N / 2개의 수열을 만들어 서로 동일한지 확인해보면 된다. 실제로 각 숫자를 선택한 이후에 `수열의 길이 / 2` 크기부터 1개의 크기 수열까지 연속된 수열이 같은지 확인하면 된다.
한 예를 들어 아래와 같은 수열이 있다고 해보자.
$$A = \{1, 2, 3, 1, 2, 3\}\quad B = \{1, 2, 3, 1, 2, 1\}$$
A라는 수열은 현재 나쁜 수열이고 B는 좋은 수열이다. 그럼 어떻게 나쁜 수열인지 확인을 해야할까? 먼저 좋은 수열의 조건을 생각해 볼 필요가 있다.

 - **임의의 길이의 인접한(연속한) 두 개의 부분 수열이 동일한 것이 존재하지 않으면 좋은 수열이다.**

여기서 ==**임의의 길이**==라는 부분의 중요한 부분인데, 이는 수열에 길이에 따라서 가능한 길이가 지속적으로 변화할 것이다. 예를 들어 앞서 본 수열의 길이가 6인 A, B 수열과 같은 경우에는 **가장 큰 크기의 연속된 두개의 부분 수열은** 수열의 크기를 3개, 3개로 잘라낸 것이다. 이처럼 수열의 길이라 N이라고 하면 N/2 크기가 가장 큰 크기의 연속된 두개의 부분 수열이라고 볼 수 있다. 따라서 가장 큰 수열을 기준으로 시작하여 가장 작은 수열 (크기가 1)이 될때 까지 모든 인접한 부분 수열이 동일하지 않으면 좋은 수열이라고 판단할 수 있다. 다만 이 방식은 수열의 크기가 홀수인지, 짝수인지에 대해서 약간의 차이를 보인다.

- **수열의 크기가 짝수인 경우**
$$C = \{1, 2, 3, 1, 2, 1\}$$
C 수열과 같이 수열의 크기가 짝수인 경우를 고려해보자. `C.size / 2`는 3으로써 여기서 3은 2가지 의미를 내포하고 있다.
1. **연속될 수 있는 수열 중 가장 큰 수열의 크기**
2. **2개로 나누어진 수열 중에서 2번째에 해당하는 수열의 첫번째 원소 인덱스**
1번 의미의 경우에는 현재 숫자 크기로 부터 수열의 크기가 1이 될때까지 비교를 진행하면 된다는 범위의 제한을 제공할 수 있다. 또한 2번의 의미는 C에서 3의 크기로 2개의 수열을 나누게 된다면 두번째 수열의 가장 첫 원소의 인덱스는 3이 될 것이다. 이처럼 비교할 대상의 인덱스의 시작점으로써 활용이 가능하게 된다. 이에 첫 시작은 `C.size / 2`의 크기인 3으로  $C_1 = \{1,2,3\},\;C_2=\{1,2,1\}$ 로 수열을 나눌 수 있다. 이때 두 수열의 각 인덱스가 같은지 비교하면 된다. 실제 구현에서의 인덱스는 $C_2$의 경우 `C.size / 2 + j` (여기서 j는 $C_2$를 순회하기 위한 반복문 변수이다.)를 활용하면 되고  $C_1$의 인덱스는 `j`를 활용하면 된다. 다만, 여기서 주의해야할 점은 실제 구현에서는 2번 의미(조건)에 의해 `int i = C.size / 2`로 초기값을 설정하고 반복문에 의해 `i`는 `C.size`의 크기까지 변화하게 된다. 이는 반복문 한 회마다 검사해야할 수열의 크기가 `C.size / 2`에서 지속적으로 1씩 감소하는 것과 같다. 따라서 코드에서의 명확한 인덱스 표현은 $C_1$은 `i + j`, $C_2$는 `i - (C.size - i) + j`가 된다. 이 모든 인덱스가 동일하다면 연속된 부분 수열이 있다고 판단할 수 있다.

- **수열의 크기가 홀수인 경우**
$$C = \{1,2,3,1,2\}$$
수열의 크기가 홀수인 경우에는 약간의 문제점이 있다. 짝수와는 달리 `C.size / 2`가 나누어 떨어지지 않기 때문에 이 값의 의미가 살짝 달라진다. 앞서 설명한 `C.size / 2`의 의미를 살펴보자.
1. **연속될 수 있는 수열 중 가장 큰 수열의 크기**
2. **2개로 나누어진 수열 중에서 2번째에 해당하는 수열의 첫번째 원소 인덱스**
여기서 $C$ 수열을 대입해보면 $5/2=2$로써 1번 조건은 만족하지만, 2번 조건에 부합하지 않는다. 2번째에 해당하는 수열의 첫번째 원소는 2가 아니라 3이다. 따라서 홀수일 때에는 2번 조건으로 활용되는 반복문 변수 `i`를 설정할 때 단순히 `C.size / 2`가 아닌 `C.size / 2 + 1`을 해주어야 한다. 필자는 삼항연산자를 이용하여 반복문 변수 `i`의 값을 홀수와 짝수로 나누어 초기값 설정을 하였다.

>🚨**주의해야할 점**
>**Q1. 수열을 하나의 정수로 표현하여 풀이하면 안될까?**
>**A1.** 123 숫자만 들어오다보니 어쩌면 정수로 풀이하려고 생각을 해볼 수도 있다. 하지만 이 문제의 최대 N은 80이다. 따라서 80자리 숫자를 정수로 다루기 위해서는 `long long` 자료형보다 훨씬 큰 자료형이 필요하게 된다. 따라서 이 문제는 문자열로 처리하거나 각 자리 수를 정수로 처리하는 방식으로 풀이해야한다.
### 풀이 코드
<hr>

``` c++
#include <iostream>
#include <vector>

std::vector<int> v;
int N;

bool chk() {
	int i = v.size() % 2 ? v.size() / 2 + 1 : v.size() / 2;
	for (; i < v.size(); i++) {
		int cnt = 0;
		for (int j = 0; j < v.size() - i; j++) {
			if (v[i + j] == v[i - (v.size() - i) + j])
				cnt += 1;
		}
		if (cnt == v.size() - i)
			return false;
	}
	return true;
}

int solve(int depth) {
	if (depth == N)
		return 1;
	for (int i = 1; i <= 3; i++) {
		v.push_back(i);
		if (chk()) {
			if (solve(depth + 1))
				return 1;
		}
		v.pop_back();
	}
	return 0;
}

int main(void) {
	std::cin >> N;
	solve(0);
	for(int i = 0; i < v.size(); i++)
		std::cout << v[i];
	std::cout << std::endl;
}
```
