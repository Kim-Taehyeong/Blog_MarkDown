---
created : 2024-03-01 09:49:44.133740
title : 백준 18222 투에-모스 문자열
tag : 분할정복
author : taehyeok
category : algorithm
---
# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/9.svg" width="30" height="40"> 백준 18222 투에-모스 문자열


### 풀이 언어 : C++

문제 구분 : #분할정복
#### [LINK - 백준 18222 투에-모스 문자열](https://www.acmicpc.net/problem/18222)

### 문제
<hr>

0과 1로 이루어진 길이가 무한한 문자열 X가 있다. 이 문자열은 다음과 같은 과정으로 만들어진다.

1. X는 맨 처음에 "0"으로 시작한다. 
2. X에서 0을 1로, 1을 0으로 뒤바꾼 문자열 X'을 만든다.
3. X의 뒤에 X'를 붙인 문자열을 X로 다시 정의한다. 
4. 2~3의 과정을 무한히 반복한다.

즉, X는 처음에 "0"으로 시작하여 "01"이 되고, "0110"이 되고, "01101001"이 되고, ⋯ 의 과정을 거쳐 다음과 같이 나타내어진다.

    "011010011001011010010110011010011001011001101001⋯⋯"

자연수 k가 주어졌을 때 X의 k번째에는 무슨 문자가 오는지 구하여라.

### 입력
<hr>

첫 번째 줄에 자연수 k (1 ≤ k ≤ $10^{18}$) 가 주어진다.
### 출력
<hr>

첫 번째 줄에 k번째에 오는 문자를 출력하라.


### 풀이 이야기
<hr>

사실 이 문제는 여러 경우의 수를 시도해보면서 점화식을 찾아나가면 쉽게 구할 수 있다.

```
0
01
0110
01101001
0110100110010110
...
```
이런 식으로 진행이 될 것이다. 이를 수식화 해본다면 아래와 같다.
$$T(0) = 0\\ T(2N) = T(N)\\ T(2n + 1) = 1 - T(n)$$

이 수식을 알아냈다면 구현자체는 매우 쉽다.

### 풀이 코드
<hr>

``` c++
#include <iostream>
#include <vector>

long long K; // 입력 변수

// Solve
int solve(long long k) {
    // K가 처음이면 0이다.
    if (k == 0)
        return 0;
    // K가 두번째면 1이다.
    else if (k == 1)
        return 1;
    // K가 짝수이면
    else if (k % 2 == 0)
        return solve(k / 2);
    else // K가 홀수이면
        return 1 - solve(k / 2);
}

int main(void) {
    // Input
    std::cin >> K;
    // Print
    std::cout << solve(K - 1) << std::endl;
}
```
