
# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/13.svg" width="30" height="40"> ë°±ì¤€ 1248 Guess

### í’€ì´ ì–¸ì–´ : C++

ë¬¸ì œ êµ¬ë¶„ : #ë°±íŠ¸ë˜í‚¹ #ì™„ì „íƒìƒ‰
#### [LINK - ë°±ì¤€ 1248 Guess](https://www.acmicpc.net/problem/1248)

### ë¬¸ì œ
<hr>


Given a sequence of integers, a1, a2, â€¦, an, we define its sign matrix S such that, for 1 â‰¤ i â‰¤ j â‰¤ n, Sij="+" if ai + â€¦ + aj > 0; Sij="âˆ’" if ai + â€¦ + aj < 0; and Sij="0" otherwise. 

For example, if (a1, a2, a3, a4)=( âˆ’1, 5, âˆ’4, 2), then its sign matrix S is a 4Ã—4 matrix: 

||||||
|-|-|-|-|-|
| |**1**|**2**|**3**|**4**|
|**1**|-|+|0|+|
|**2**| |+|+|+|
|**3**| | |-|-|
|**4**| | | |+|

We say that the sequence (âˆ’1, 5, âˆ’4, 2) generates the sign matrix. A sign matrix is valid if it can be generated by a sequence of integers. 

Given a sequence of integers, it is easy to compute its sign matrix. This problem is about the opposite direction: Given a valid sign matrix, find a sequence of integers that generates the sign matrix. Note that two or more different sequences of integers can generate the same sign matrix. For example, the sequence (âˆ’2, 5, âˆ’3, 1) generates the same sign matrix as the sequence (âˆ’1,5, âˆ’4,2). 

Write a program that, given a valid sign matrix, can find a sequence of integers that generates the sign matrix. You may assume that every integer in a sequence is between âˆ’10 and 10, both inclusive.

### ì…ë ¥
<hr>

The first line contains an integer n(1 â‰¤ n â‰¤ 10), where n is the length of a sequence of integers. The second line contains a string of n(n+1)/2 characters such that the first n characters correspond to the first row of the sign matrix, the next nâˆ’1 characters  to the second row, ..., and the last character to the n-th row. 
### ì¶œë ¥
<hr>

Output exactly one line containing a sequence of n integers which generates the sign matrix. If more than one sequence generates the sign matrix, you may output any one of them. Every integer in the sequence must be between âˆ’10 and 10, both inclusive.
### í’€ì´ ì´ì•¼ê¸°
<hr>

ì´ ë¬¸ì œëŠ” ë°±íŠ¸ë˜í‚¹ì„ í™œìš©í•´ì„œ Metrixì— ì •ë³´ë¡œ ì£¼ì–´ì§„ ë¶€í˜¸ì •ë³´ì— ë§ëŠ” Nê°œì˜ ìˆ«ìë¥¼ ì„ íƒí•˜ëŠ” ë¬¸ì œì´ë‹¤. ë¨¼ì € í•µì‹¬ í’€ì´ ì•„ì´ë””ì–´ëŠ” (depth, depth)ì˜ ë¶€í˜¸ì •ë³´ë¥¼ í™œìš©í•˜ë©´ depthë²ˆì§¸ì˜ ìˆ«ìì˜ ë¶€í˜¸ë¥¼ ì•Œ ìˆ˜ ìˆë‹¤. ì´ë¥¼ í™œìš©í•˜ë©´ -10 ~ 10ê¹Œì§€ ì‹œë„í•˜ëŠ” ê²ƒì´ ì•„ë‹Œ -10 ~ -1 ê¹Œì§€ë§Œ ì‹œë„í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë§ì€ ê²½ìš°ì˜ ìˆ˜ë¥¼ ì œê±°í•  ìˆ˜ ìˆë‹¤.
```c++
bool solve(int depth) {
    // ê¸°ì € ì‚¬ë¡€ : Nê°œì˜ ìˆ«ìë¥¼ ì„ íƒí•˜ëŠ” ê²½ìš°
    if (depth == N)
        return true;
    // (depth, depth) ê°€ -ì¸ ê²½ìš°
    if (S[depth][depth] == '-') {
        for (int i = -1; i >= -10; i--) {
            if (avail(depth, i)) {
                setNumber(depth, i);
                if (solve(depth + 1))
                    return true;
                resetNumber(depth);
            }
        }
    }
    ...
    return false;
}
```
ë¨¼ì € ê¸°ì € ì‚¬ë¡€ë¥¼ ì‚´í´ë³´ë©´ Nê°œì˜ ìˆ«ìë¥¼ ëª¨ë‘ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì™€ ê°™ë‹¤. ì´í›„ ì´ì „ì— ì„¤ëª…í•œ (depth, depth) ê·œì¹™ì„ í™œìš©í•˜ì—¬ ìŒìˆ˜, ì–‘ìˆ˜, 0ì¤‘ í•˜ë‚˜ë¥¼ íŒë³„í•œë‹¤. ê·¸ëŸ° ë‹¤ìŒì— ëª¨ë“  ìŒìˆ˜ ì¤‘ì—ì„œ ìœ ë§í•œ ìŒìˆ˜ì— ëŒ€í•´ì„œë§Œ ë°±íŠ¸ë˜í‚¹ì„ ì§„í–‰í•œë‹¤. ê·¸ë ‡ë‹¤ë©´ ì–´ë–»ê²Œ ìœ ë§í•œì§€ íŒë³„í•  ìˆ˜ ìˆì„ê¹Œ?
```c++
// Numberê°€ ì‚¬ìš© ê°€ëŠ¥í•œì§€ íŒë³„
bool avail(int depth, int num) {
    for (int i = 0; i <= depth; i++) {
        int val = num;
        if (depth > 0 && S[i][depth - 1] != ' ')
            val += IS[i][depth - 1];
        if (val > 0 && S[i][depth] != '+')
            return false;
        if (val < 0 && S[i][depth] != '-')
            return false;
        if (val == 0 && S[i][depth] != '0')
            return false;
    }
    return true;
}
```
í˜„ì¬ `depth`ì—´ê³¼ `depth - 1`ê¹Œì§€ì˜ í•©ì„ í˜„ì¬ ìœ„ì¹˜ì˜ ë¶€í˜¸ì™€ ë¹„êµí•˜ì—¬ ì˜³ì€ì§€ ì•„ë‹Œì§€ êµ¬ë¶„í•œë‹¤. `depth`ì—´ì˜ ëª¨ë“  ê°’ì— ëŒ€í•´ì„œ ì¡°ê±´ì— ë¶€í•©í•œë‹¤ë©´ í•´ë‹¹ ìˆ«ìë¥¼ ì„ íƒí•˜ë„ë¡ í•œë‹¤. ì¶”ê°€ë¡œ `depth - 1`ê¹Œì§€ì˜ í•©ì€ ë§¤ë²ˆ ì§€ì†ì ìœ¼ë¡œ ë”í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ `IS` ë°°ì—´ì„ í™œìš©í•˜ì—¬ ì§€ì†ì ìœ¼ë¡œ ì €ì¥í•˜ì—¬ ë”í•˜ë„ë¡ í•œë‹¤.

ğŸš¨**ì£¼ì˜í•´ì•¼í•  ì **
>**Q1. 10ì€ í¬í•¨ì¸ê°€ìš”?**  
>**A1.** 0 ~ 9ê¹Œì§€ í•œìë¦¬ ìˆ«ìë§Œ ê°€ëŠ¥í•œ ê²ƒì´ ì•„ë‹ˆë¼ 10ê³¼ -10ë„ í¬í•¨ì´ë¼ëŠ” ì‚¬ì‹¤ì„ ê¼­ ìŠì§€ ë§™ì‹œë‹¤.


### í’€ì´ ì½”ë“œ
<hr>

``` c++
#include <iostream>
#include <vector>
#include <string>

int N;
std::vector<std::vector<char>> S; // ì…ë ¥ ë³€ìˆ˜
std::vector<std::vector<int>> IS; // ì´ì „ ê¹Œì§€ì˜ í•© ì €ì¥ ë°°ì—´
std::vector<int> ans; // ì„ íƒ ìˆ«ì ë°°ì—´

// Number ì‚¬ìš© ì·¨ì†Œ
void resetNumber(int depth) {
    ans.pop_back();
    for (int i = 0; i <= depth; i++)
        IS[i][depth] = 0;
}

// Number ì‚¬ìš© ì‹œë„
void setNumber(int depth, int num) {
    ans.push_back(num);
    for (int i = 0; i <= depth; i++) {
        int val = num;
        if (depth > 0 && S[i][depth - 1] != ' ')
            val += IS[i][depth - 1];
        IS[i][depth] = val;
    }
}

// Numberê°€ ì‚¬ìš© ê°€ëŠ¥í•œì§€ íŒë³„
bool avail(int depth, int num) {
    for (int i = 0; i <= depth; i++) {
        int val = num;
        if (depth > 0 && S[i][depth - 1] != ' ')
            val += IS[i][depth - 1];
        if (val > 0 && S[i][depth] != '+')
            return false;
        if (val < 0 && S[i][depth] != '-')
            return false;
        if (val == 0 && S[i][depth] != '0')
            return false;
    }
    return true;
}

// Solve
bool solve(int depth) {
    // ê¸°ì € ì‚¬ë¡€ : Nê°œì˜ ìˆ«ìë¥¼ ì„ íƒí•˜ëŠ” ê²½ìš°
    if (depth == N)
        return true;
    // (depth, depth) ê°€ -ì¸ ê²½ìš°
    if (S[depth][depth] == '-') {
        for (int i = -1; i >= -10; i--) {
            if (avail(depth, i)) {
                setNumber(depth, i);
                if (solve(depth + 1))
                    return true;
                resetNumber(depth);
            }
        }
    }
    // (depth, depth) ê°€ +ì¸ ê²½ìš°
    else if (S[depth][depth] == '+') {
        for (int i = 1; i <= 10; i++) {
            if (avail(depth, i)) {
                setNumber(depth, i);
                if (solve(depth + 1))
                    return true;
                resetNumber(depth);
            }
        }
    }
    // (depth, depth) ê°€ 0ì¸ ê²½ìš°
    else if (S[depth][depth] == '0') {
        if (avail(depth, 0)) {
            setNumber(depth, 0);
                if (solve(depth + 1))
                    return true;
            resetNumber(depth);
        }
    }
    return false;
}

int main(void) {
    // Input
    std::string tmp;
    std::cin >> N;
    std::cin >> tmp;
    int idx = 0;
    for (int i = 0; idx < tmp.size(); i++) {
        std::vector<char> vtmp;
        std::vector<int> vtmp2;
        for (int k = 0; k < i; k++) {
            vtmp.push_back(' ');
            vtmp2.push_back(0);
        }
        for (int j = 0; j < N - i; j++) {
            vtmp.push_back(tmp[idx]);
            vtmp2.push_back(0);
            idx += 1;
        }
        IS.push_back(vtmp2);
        S.push_back(vtmp);
    }
    // Solve
    solve(0);
    // Print
    for (int i = 0; i < ans.size(); i++)
        std::cout << ans[i] << " ";
    std::cout << std::endl;
}
```
