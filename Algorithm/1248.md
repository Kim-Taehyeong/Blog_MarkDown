
# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/13.svg" width="30" height="40"> 백준 1248 Guess

### 풀이 언어 : C++

문제 구분 : #백트래킹 #완전탐색
#### [LINK - 백준 1248 Guess](https://www.acmicpc.net/problem/1248)

### 문제
<hr>


Given a sequence of integers, a1, a2, …, an, we define its sign matrix S such that, for 1 ≤ i ≤ j ≤ n, Sij="+" if ai + … + aj > 0; Sij="−" if ai + … + aj < 0; and Sij="0" otherwise. 

For example, if (a1, a2, a3, a4)=( −1, 5, −4, 2), then its sign matrix S is a 4×4 matrix: 

||||||
|-|-|-|-|-|
| |**1**|**2**|**3**|**4**|
|**1**|-|+|0|+|
|**2**| |+|+|+|
|**3**| | |-|-|
|**4**| | | |+|

We say that the sequence (−1, 5, −4, 2) generates the sign matrix. A sign matrix is valid if it can be generated by a sequence of integers. 

Given a sequence of integers, it is easy to compute its sign matrix. This problem is about the opposite direction: Given a valid sign matrix, find a sequence of integers that generates the sign matrix. Note that two or more different sequences of integers can generate the same sign matrix. For example, the sequence (−2, 5, −3, 1) generates the same sign matrix as the sequence (−1,5, −4,2). 

Write a program that, given a valid sign matrix, can find a sequence of integers that generates the sign matrix. You may assume that every integer in a sequence is between −10 and 10, both inclusive.

### 입력
<hr>

The first line contains an integer n(1 ≤ n ≤ 10), where n is the length of a sequence of integers. The second line contains a string of n(n+1)/2 characters such that the first n characters correspond to the first row of the sign matrix, the next n−1 characters  to the second row, ..., and the last character to the n-th row. 
### 출력
<hr>

Output exactly one line containing a sequence of n integers which generates the sign matrix. If more than one sequence generates the sign matrix, you may output any one of them. Every integer in the sequence must be between −10 and 10, both inclusive.
### 풀이 이야기
<hr>

이 문제는 백트래킹을 활용해서 Metrix에 정보로 주어진 부호정보에 맞는 N개의 숫자를 선택하는 문제이다. 먼저 핵심 풀이 아이디어는 (depth, depth)의 부호정보를 활용하면 depth번째의 숫자의 부호를 알 수 있다. 이를 활용하면 -10 ~ 10까지 시도하는 것이 아닌 -10 ~ -1 까지만 시도할 수 있기 때문에 많은 경우의 수를 제거할 수 있다.
```c++
bool solve(int depth) {
    // 기저 사례 : N개의 숫자를 선택하는 경우
    if (depth == N)
        return true;
    // (depth, depth) 가 -인 경우
    if (S[depth][depth] == '-') {
        for (int i = -1; i >= -10; i--) {
            if (avail(depth, i)) {
                setNumber(depth, i);
                if (solve(depth + 1))
                    return true;
                resetNumber(depth);
            }
        }
    }
    ...
    return false;
}
```
먼저 기저 사례를 살펴보면 N개의 숫자를 모두 사용하는 경우와 같다. 이후 이전에 설명한 (depth, depth) 규칙을 활용하여 음수, 양수, 0중 하나를 판별한다. 그런 다음에 모든 음수 중에서 유망한 음수에 대해서만 백트래킹을 진행한다. 그렇다면 어떻게 유망한지 판별할 수 있을까?
```c++
// Number가 사용 가능한지 판별
bool avail(int depth, int num) {
    for (int i = 0; i <= depth; i++) {
        int val = num;
        if (depth > 0 && S[i][depth - 1] != ' ')
            val += IS[i][depth - 1];
        if (val > 0 && S[i][depth] != '+')
            return false;
        if (val < 0 && S[i][depth] != '-')
            return false;
        if (val == 0 && S[i][depth] != '0')
            return false;
    }
    return true;
}
```
현재 `depth`열과 `depth - 1`까지의 합을 현재 위치의 부호와 비교하여 옳은지 아닌지 구분한다. `depth`열의 모든 값에 대해서 조건에 부합한다면 해당 숫자를 선택하도록 한다. 추가로 `depth - 1`까지의 합은 매번 지속적으로 더하는 것이 아니라 `IS` 배열을 활용하여 지속적으로 저장하여 더하도록 한다.

🚨**주의해야할 점**
>**Q1. 10은 포함인가요?**  
>**A1.** 0 ~ 9까지 한자리 숫자만 가능한 것이 아니라 10과 -10도 포함이라는 사실을 꼭 잊지 맙시다.


### 풀이 코드
<hr>

``` c++
#include <iostream>
#include <vector>
#include <string>

int N;
std::vector<std::vector<char>> S; // 입력 변수
std::vector<std::vector<int>> IS; // 이전 까지의 합 저장 배열
std::vector<int> ans; // 선택 숫자 배열

// Number 사용 취소
void resetNumber(int depth) {
    ans.pop_back();
    for (int i = 0; i <= depth; i++)
        IS[i][depth] = 0;
}

// Number 사용 시도
void setNumber(int depth, int num) {
    ans.push_back(num);
    for (int i = 0; i <= depth; i++) {
        int val = num;
        if (depth > 0 && S[i][depth - 1] != ' ')
            val += IS[i][depth - 1];
        IS[i][depth] = val;
    }
}

// Number가 사용 가능한지 판별
bool avail(int depth, int num) {
    for (int i = 0; i <= depth; i++) {
        int val = num;
        if (depth > 0 && S[i][depth - 1] != ' ')
            val += IS[i][depth - 1];
        if (val > 0 && S[i][depth] != '+')
            return false;
        if (val < 0 && S[i][depth] != '-')
            return false;
        if (val == 0 && S[i][depth] != '0')
            return false;
    }
    return true;
}

// Solve
bool solve(int depth) {
    // 기저 사례 : N개의 숫자를 선택하는 경우
    if (depth == N)
        return true;
    // (depth, depth) 가 -인 경우
    if (S[depth][depth] == '-') {
        for (int i = -1; i >= -10; i--) {
            if (avail(depth, i)) {
                setNumber(depth, i);
                if (solve(depth + 1))
                    return true;
                resetNumber(depth);
            }
        }
    }
    // (depth, depth) 가 +인 경우
    else if (S[depth][depth] == '+') {
        for (int i = 1; i <= 10; i++) {
            if (avail(depth, i)) {
                setNumber(depth, i);
                if (solve(depth + 1))
                    return true;
                resetNumber(depth);
            }
        }
    }
    // (depth, depth) 가 0인 경우
    else if (S[depth][depth] == '0') {
        if (avail(depth, 0)) {
            setNumber(depth, 0);
                if (solve(depth + 1))
                    return true;
            resetNumber(depth);
        }
    }
    return false;
}

int main(void) {
    // Input
    std::string tmp;
    std::cin >> N;
    std::cin >> tmp;
    int idx = 0;
    for (int i = 0; idx < tmp.size(); i++) {
        std::vector<char> vtmp;
        std::vector<int> vtmp2;
        for (int k = 0; k < i; k++) {
            vtmp.push_back(' ');
            vtmp2.push_back(0);
        }
        for (int j = 0; j < N - i; j++) {
            vtmp.push_back(tmp[idx]);
            vtmp2.push_back(0);
            idx += 1;
        }
        IS.push_back(vtmp2);
        S.push_back(vtmp);
    }
    // Solve
    solve(0);
    // Print
    for (int i = 0; i < ans.size(); i++)
        std::cout << ans[i] << " ";
    std::cout << std::endl;
}
```
