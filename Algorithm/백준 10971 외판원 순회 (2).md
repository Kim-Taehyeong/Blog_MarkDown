문제 구분 : #백트래킹 #완전탐색 
##### [문제 - 백준 10971 외판원 순회 (2)](https://www.acmicpc.net/problem/10971)

### 문제
<hr>

외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자. 1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다. 각 도시간에 이동하는데 드는 비용은 행렬 $W[i][j]$형태로 주어진다. $W[i][j]$는 도시 $i$에서 도시 $j$로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, $W[i][j]$ 는 $W[j][i]$와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. $W[i][i]$는 항상 0이다. 경우에 따라서 도시 $i$에서 도시 $j$로 갈 수 없는 경우도 있으며 이럴 경우 $W[i][j]=0$ 이라고 하자. $N$과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원 의 순회 여행 경로를 구하는 프로그램을 작성하시오.

### 입력
<hr>

첫째 줄에 도시의 수 $N$이 주어진다. $(2 ≤ N ≤ 10)$ 다음 $N$개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. $W[i][j]$는 도시 $i$에서 $j$로 가기 위한 비용을 나타낸다. 항상 순회할 수 있는 경우만 입력으로 주어진다.
### 출력
<hr>

첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.
### 풀이 이야기
<hr>

이 문제는 여러 가지의 경로를 모두 방문한 뒤에 가장 작은 비용을 출력하도록하면 해결이 가능하다. 사실 완전탐색 영역이기에 알고리즘 아이디어보다는 구현 능력이 더 중요한 것 같다. 먼저 완전 탐색을 하기 위해서 재귀 함수를 활용 했는데, 재귀 함수를 활용할 때 가장 중요한 점은 기저사례를 지정하는 것이다. 이 문제에서 정한 기저 사례는 다음과 같다.

 - **현재 계산한 Cost(비용)이 지금 결과보다 클 경우**
 - **모든 지역에 방문한 경우한 경우**

이 두가지로 구분할 수 있다. 먼저 현재 Cost가 지금 결과보다 큰 경우는 완전탐색을 하는 과정에서 이전 결과보다 클 경우 더 이상 탐색을 진행할 필요가 없다. 불필요한 연산을 줄이기 위한 최적화 방식에 하나이다.
두 번째는 모든 지역에 방문한 경우이다. `vcnt`변수가 현재 방문한 지역의 개수인데, N개의 지역을 모두 방문했다면 더 이상 탐색을 하지 말아야한다. 이 두가지 기저 사례를 가지고 탐색을 진행한다. 백트래킹을 진행하는 과정에서는 현재 위치에서 모든 지역으로 이동을 시도하는데, 여기서 방문을 했던 곳 아니면 갈 수 없는 곳 ($W[i][j]$가 0인 곳)을 빼고 모두 방문한다.

🚨**주의해야할 점**
>**Q1. 모든 방문을 마치면 어떻게 해야할까?**  
>**A1.** 모든 방문을 마친다면 시작 위치로 돌아가야 한다. *문제를 꼭 잘 읽자… 필자는 이 문제로 고민을 오래했다* 따라서 기저사례에서 마지막으로 시작위치로 돌아가는 코드를 넣어줘야하고 항상 시작 위치로 돌아가는 경우가 존재하는 건 아니기 때문에, 조건문을 통해서 시작으로 돌아갈 수 있는지 확인해야한다.
### 풀이 코드
<hr>

``` c++
#include <iostream>
#include <vector>

std::vector<std::vector<int>> W; // 각 간선(edge)간 가중치
std::vector<bool> visited; // 방문 Check 배열
int ret = 2147483647; // 최소 비용
int N; // Input 변수

// Backtracking
void solve(int st, int pos, int cost, int vcnt) {
	if (cost > ret) // 이미 최소 비용을 넘었다면 Ret
		return ;
	if (vcnt == N) { // 모든 지역 방문 시
		// 출발지 회귀가 가능하다면 Update
		if (W[pos][st])
			ret = std::min(ret, cost + W[pos][st]);
		return ;
	}
	visited[pos] = true; // 현재 위치 방문
	// N개 방면 순회
	for (int i = 0; i < N; i++) {
		// 방문지 OR 길이 없다면 PASS
		if (!W[pos][i] || visited[i])
			continue ;
		visited[i] = true; // 방문지 Check
		solve(st, i, cost + W[pos][i], vcnt + 1); // 재귀 호출
		visited[i] = false; // 방문지 Check 해제
	}
	visited[pos] = false; // 현재 위치 해제
}

int main(void) {
	// Input
	std::cin >> N;
	for (int i = 0; i < N; i++) {
		std::vector<int> v;
		for (int j = 0; j < N; j++) {
			int tmp;
			std::cin >> tmp;
			v.push_back(tmp);
		}
		W.push_back(v);
		visited.push_back(false);
	}
	// Solve
	for (int i = 0; i < N; i++)
		solve(i, i, 0, 1);
	// Print
	std::cout << ret << "\n";
}
```


