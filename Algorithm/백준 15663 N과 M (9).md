문제 구분 : #백트래킹 #완전탐색 
##### [문제 - 백준 15663 N과M (9)](https://www.acmicpc.net/problem/15663)

### 문제
<hr>

N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.
- N개의 자연수 중에서 M개를 고른 수열
### 입력
<hr>

첫째 줄에 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)
둘째 줄에 N개의 수가 주어진다. 입력으로 주어지는 수는 10,000보다 작거나 같은 자연수이다.
### 출력
<hr>

한 줄에 하나 씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.
### 풀이 이야기
<hr>

이 문제는 기존 N과 M 시리즈와 매우 유사한 성격을 띄고 있지만, 생각보다 많은 다른 점을 가지고 있다. 문제 상에서 적혀있는 다른 점은 **중복되는 수열을 여러번 출력하면 안된다.** 라는 조건이다. 이 문장에는 2가지 의미를 내포하고 있다.

1. **이전에 사용한 숫자는 사용해선 안된다.**
 이전에 사용한 숫자를 사용해서는 안된다는 조건은 앞선 N과 M 시리즈와 유사한 형태의 조건이다. 예를 들어 (1, 9, 9)라는 수열에서 2가지 숫자를 뽑는다고 가정해보자. 이 수열에서 첫번째로 나와야할 수열은 (1, 1)일까? 아니면 (1, 9)일까를 생각해보면 바로 이해할 수 있다. 정답은 (1, 9)이다. 왜냐면 (N1, N2)라고 표현했을 때 처음 N1에서 1을 택했다면 원래 수열에서는 더 이상 1이 남아있지 않는다. 따라서 N2에는 1을 선택할 수 없다. 따라서 9를 선택할 수 밖에 없고 이에 (1, 9)라는 수열이 가장 처음의 수열이라고 할 수 있다.

2. **이전에 사용한 수열은 사용해선 안된다.**
이전에 사용한 수열을 사용해서는 안된다는 조건은 1번 조건과 조금 유사해 보이지만 다른 의미를 가지고 있다. 앞서 설명한 예제와 같은 상황인 (1, 9, 9)라는 수열을 생각해보자. 여기서 2가지 숫자를 뽑을 때 9가 2가지 있기 때문에 (1, 9)는 2번 뽑을 경우가 가능하다. 하지만 문제 조건에 따라서 해당 겹치는 수열들은 단 한 번만 출력해야한다.

앞서 필요한 조건을 수행하기 위해서는 1번 조건은 `visited`배열을 활용해서 해결할 수 있다. 2번 조건의 경우에는 결국 같은 `depth`에서 같은 숫자를 뽑지 말라는 것이다. (X1, X2, X3)라는 수열에서 X1에 1이 두 번 사용될 수 없다는 의미랑 같다. 이는 미리 배열을 정렬한 후에 `last`라는 변수에 이전에 사용한 값을 저장하여 만약 사용을 했다면 `continue`하는 방식을 채택하여 해결했다.

처음 문제를 풀이할 때 1번과 2번과 같이 조건을 제대로 정립하지 못하고, 출력을 통해 조건을 추측하며 풀이를 하여 반례케이스가 많이 발생하는 어려움이 있었다. 이에 `last`를 활용하여 2번 조건을 해결하지 않고 `cnt`배열을 통해서 각 숫자들의 개수를 세는 방식으로 처음 구현을 하였는데, 2번 조건을 만족시키지 못했다. 단순히 출력을 보고 풀 수 있는 다른 N과 M시리즈와는 다르게 문제에 주어진 조건을 차분히 생각 후에 조건을 정리하면 쉽게 풀 수 있는 문제였다.

### 풀이 코드
<hr>

``` c++
#include <iostream>
#include <vector>
#include <algorithm>

int N, M;
std::vector<int> v;
std::vector<bool> v2;
std::vector<int> ret;

void prt_vector() {
	for(size_t i = 0; i < ret.size(); i++)
		std::cout << ret[i] << " ";
	std::cout << "\n";
}

void solve(int depth) {
	int last = -1;
	if (depth == M) {
		prt_vector();
		return ;
	}
	for (int i = 0; i < N; i++) {
		if (v2[i] || last == v[i])
			continue ;
		last = v[i];
		v2[i] = true;
		ret.push_back(v[i]);
		solve(depth + 1);
		ret.pop_back();
		v2[i] = false;
	}
}

int main(void) {
	std::cin >> N >> M;
	for (int i = 0; i < N; i++) {
		int tmp;
		std::cin >> tmp;
		v2.push_back(false);
		v.push_back(tmp);
	}
	std::sort(v.begin(), v.end());
	solve(0);
}
```


