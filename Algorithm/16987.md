---
created : 2024-03-01 09:49:44.117740
title : 백준 16987 계란으로 계란치기
tag : 백트래킹 완전탐색 
author : taehyeok
category : algorithm
---
# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/11.svg" width="30" height="40"> 백준 16987 계란으로 계란치기

### 풀이 언어 : C++

문제 구분 : #백트래킹 #완전탐색 
#### [LINK - 백준 16987 계란으로 계란치기](https://www.acmicpc.net/problem/16987)

### 문제
<hr>

원래 프로그래머의 기본 소양은 팔굽혀펴기를 단 한 개도 할 수 없는 것이라고 하지만 인범이는 3대 500을 넘기는 몇 안되는 프로그래머 중 한 명이다. 인범이는 BOJ에서 틀린 제출을 할 때마다 턱걸이를 5회 하는 기적의 운
동 루틴을 통해 뇌와 근육을 동시에 단련한다. 근육을 단련할 때 식단이 정말로 중요하다는 것을 아는 인범이는 탄수화물이 많은 밥이나 빵 따위의 아침 식사를 대신해 단백질이 많은 계란찜을 해먹는다. 계란찜을 먹기 위해서는 계란을 깨야 하는데, 인범이는 힘이 너무 넘치는 나머지 부엌의 대리석을 이용해 계란을 깨면 늘 껍데기가 산산조각나 뒷처리가 너무 어렵게 되곤한다. 어떻게 하면 계란을 조심스럽게 깰 수 있을까 고민하던 인범이에게 유현이는 굉장히 좋은 해결책을 알려주었다. 바로 계란으로 계란을 치는 것이다. 계란끼리 부딪쳐보니 껍데기가 아주
예쁘게 갈라지는 것을 발견한 인범이는 앞으로 계란으로 계란을 쳐서 식사 준비를 해야겠다고 생각했다. 유현이는 더 나아가 식사 준비를 할 때에도 두뇌를 단련할 수 있는 좋은 퍼즐을 인범이에게 알려주었다. 문제를 소개하기 전, 계란으로 계란을 치게 될 경우 어떤 일이 벌어지는지를 먼저 이해하고 가자. 각 계란에는 내구도와 무게가 정해져있다. 계란으로 계란을 치게 되면 각 계란의 내구도는 상대 계란의 무게만큼 깎이게 된다. 그리고 내구도가 0 이하가 되는 순간 계란은 깨지게 된다. 예를 들어 계란 1의 내구도가 7, 무게가 5이고 계란 2의 내구도가 3, 무게가 4라고 해보자. 계란 1으로 계란 2를 치게 되면 계란 1의 내구도는 4만큼 감소해 3이 되고 계란 2의 내구도는 5만큼 감소해 -2가 된다. 충돌 결과 계란 1은 아직 깨지지 않았고 계란 2는 깨졌다. 유현이가 인범이에게 알려준 퍼즐은 일렬로 놓여있는 계란에 대해 왼쪽부터 차례로 들어서 한 번 씩만 다른 계란을 쳐 최대한 많은 계란을 깨는 문제였
다. 구체적으로 계란을 치는 과정을 설명하면 아래와 같다.
1. 가장 왼쪽의 계란을 든다.
2. 손에 들고 있는 계란으로 깨지지 않은 다른 계란 중에서 하나를 친다. 단, 손에 든 계란이 깨졌거나 깨지지 않은 다른 계란이 없으면 치지 않고 넘어간다. 이후 손에 든 계란을 원래 자리에 내려놓고 3번 과정을 진행한다.
3. 가장 최근에 든 계란의 한 칸 오른쪽 계란을 손에 들고 2번 과정을 다시 진행한다. 단, 가장 최근에 든 계란이 가장 오른쪽에 위치한 계란일 경우 계란을 치는 과정을 종료한다.

이 과정을 통해 최대한 많은 계란을 깨는 것이 앞으로 인범이가 매일 아침마다 풀게 될 퍼즐이다. 그리고 유현이는 인범이가 찾은 답이 정답이 맞는지 확인해주려고 한다. 일렬로 놓인 계란들의 내구도와 무게가 차례대로 주어졌을 때 최대 몇 개의 계란을 깰 수 있는지 알아맞춰보자.
### 입력
<hr>

첫째 줄에 계란의 수를 나타내는 N(1 ≤ N ≤ 8)가 주어진다. 그 다음 N개의 줄에는 계란의 내구도와 무게에 대한 정보가 주어진다. i+1번째 줄에는 왼쪽에서 i번째에 위치한 계란의 내구도 S (1 ≤ S ≤ 300)와 무게 W (1 ≤ W ≤ 300)가 한 칸의 빈칸을 사이에 두고 주어진다.
### 출력
<hr>

첫째 줄에 인범이가 깰 수 있는 계란의 최대 개수를 출력한다.
### 풀이 이야기
<hr>

처음에 사실 문제 이해부터 조금의 문제가 있었다. 2번 과정에 대해서 해석에 대한 고민이 있었는데, 결론부터 설명하자면 하나를 들고 나머지 하나를 치는 것이다. 즉 과정을 조금 쉽게 다시 설명해보자면,

1. 현재 가장 왼쪽 (0번째) 계란을 든다.
2. 자신을 제외한 나머지 계란 중에 마음에 드는 계란을 친다.
3. 무엇이 깨지든 안깨지든 일단 원래 자리에 내려 놓는다.
4. 다음 계란으로 넘어간다. (1번째) 만약, 1번이 깨졌다면 2번으로 넘어간다. (안깨진거 만날때 까지 넘어간다.)
5. 계속 넘겼는데 가장 오른쪽 (N-1번째) 계란이 된다면 멈춘다. (이 계란이 깨져 있지 않다면 다른 걸 깬 후에)

따라서 내가 든 계란이 깨졌든 안깨졌든은 크게 상관이 없다. 계란의 index는 순차적으로 오른쪽으로 하나씩 이동한다. 이 포인트만 이해한다면 문제가 조금은 단순해질 것이다. 단순히 순차적으로 계란을 깨보면 된다. 결국 문제는 계란으로 어떤 계란을 쳐야 가장 효율적으로 많은 계란을 깰 수 있는지가 관건이다. 그래서 각 index에 있는 계란으로 남은 모든 계란을 시도해보면 된다. 물론 깨지지 않은 계란만 깰 수 있다.

**🚨주의해야할 점**
>**Q1. 계란의 체력이 언제일때 깨진걸까?**  
>**A1.** 계란의 체력이 0이라도 계란은 깨진 것이다. 무언가 자꾸 틀린다면 꼭 확인해보아라.

>**Q2. 계란은 재귀호출이 될까?**  
>**A2.** 계란은 함수가 아니다. 재귀 호출처럼 자신 계란이 자신을 때릴 수 없다.

>**Q3. 계란을 다른 계란을 치지 않고 넘길 수 있나?**  
>**A3.** 계란은 치지 않고 넘길 수 없다. 이 문제도 꽤 도움이 되는 케이스이다. 간혹가다 지금 계란으로 아무것도 깨지 않고 넘어가면 더 많은 계란을 깰 수 있는 경우도 있다. 하지만, 문제에 명시되었듯 우리는 들고있는 계란을 넘길 수 없다. 꼭 명심하자.
```
Case Q3

In :
8
7 100
6 100
100 1
100 1
100 1
100 1
100 1
100 1

Out :
6
```
### 풀이 코드
<hr>

``` c++
#include <iostream>
#include <vector>

int N, ret;
std::vector<int> d;
std::vector<int> h;

void solve(int index, int crash) {
	// 기저 사례 : 마지막 계란을 선택한 경우
	if (index == N) {
		ret = std::max(crash, ret); // Max Crash Update
		return ;
	}
	bool available = true;
	int rcrash = crash; // 이전 회차 까지 깨진 계란의 수
	// 0 ~ N - 1번의 계란 치기
	for (int i = 0; i < N; i++) {
		// 이미 깨진 계란이거나 자기 자신이라면 PASS
		if (h[i] <= 0 || h[index] <= 0 || i == index)
			continue ;
		// 계란 치기
		available = false;
		h[i] -= d[index];
		h[index] -= d[i];
		if (h[i] <= 0) // 상대 계란이 깨지면
			crash += 1;
		if (h[index] <= 0) // 손에 계란이 깨지면
			crash += 1;
		solve(index + 1, crash); // 재귀 호출
		crash = rcrash; // 깨진 계란 수 복귀
		// 계란 치기 복귀
		h[i] += d[index];
		h[index] += d[i];
	}
	if (available) // 아무 계란도 못쳤다면 (선택된 계란이 깨짐)
		solve(index + 1, crash);
}

int main(void) {
	// Input
	std::cin >> N;
	for (int i = 0; i < N; i++) {
		int damage, hp;
		std::cin >> hp >> damage;
		d.push_back(damage);
		h.push_back(hp);
	}
	// Solve
	solve(0, 0);
	// Print
	std::cout << ret << std::endl;
}
```
