---
created : 2024-03-01 10:29:46.553734
title : 백준 2212 센서
tag : [그리디]
author : taehyeok
category : algorithm
---
# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/11.svg" width="30" height="40"> 백준 2212 센서


### 풀이 언어 : C++

문제 구분 : #그리디
#### [LINK - 백준 2212 센서](https://www.acmicpc.net/problem/2212)

### 문제

<hr>


한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.

각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.

편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.

### 입력

<hr>


첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.
### 출력

<hr>


첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.
### 풀이 이야기

<hr>


이 문제는 그리드로 해결할 수 있는 문제이다. 먼저 어디어디에 집중국을 세울지를 선택하는 방식으로 사고하기 보다는 다른 방식으로 사고하는 것이 문제를 해결하는데 조금 더 도움이 된다. K개의 집중국을 세운다는 표현이 아닌 센서들을 K개의 그룹으로 나눈다고 생각하면 된다. 따라서 K개의 그룹으로 나누기 위해서는 K-1개의 구분자가 필요하다. 

예를 들면 (1,2,3,4,5,6,6,7)의 센서들이 있다고 가정해보자. K=3인 크기로 구역을 나눈다고 가정하면 K-1 즉 2개의 구분자가 필요하다. (1,2 | 3,4,5 | 6,6,7) 이런 식으로 2개의 구분자를 통해서 나눌 수 있다.

따라서 이 문제는 어떤 지점에 구분자를 넣을 것인지 선택하는 문제이다. 그러면 백트래킹으로 모든 구분자를 탐색해야할까? 그렇게 해도 문제는 없겠지만, 센서가 1만개까지 가능하기 때문에 시간안에 풀이하기 쉽지 않을 것이다. 따라서, 그리디 방식으로 가장 지점 사이의 거리가 가장 먼 K - 1개의 구간에만 구분자를 두는 방식으로 풀이를 진행하면 모든 경우의 수를 확인하지 않고도 정답을 구할 수 있다.

```c++
    // 거리에 대한 배열 만들기
    for (int i = 0; i < v.size() - 1; i++)
        dist.push_back(v[i + 1] - v[i]);
    // 거리 정렬
    std::sort(dist.begin(), dist.end());
```
먼저 지점사이의 가장 큰 길이 K - 1개를 알아내기 위해서 지점 사이의 거리 배열을 만들어주고 정렬을 하였다.

```c++
    for (int i = 0; i < K - 1; i++)
        dist.pop_back();
    // 남은 거리 지점 합 구하기
    for (int i = 0; i < dist.size(); i++)
        ret += dist[i];
```
다음으로 K - 1개의 지점에 구분자를 둔다고 생각하면서 거리를 삭제한다. 그렇게 하면 현재 센서들은 K개의 그룹으로 나누어져있는 상태일 것이다. 이때 남은 지점간의 거리를 모두 더하면 집중국의 필요 거리의 합을 구할 수 있게 된다.

### 풀이 코드

<hr>


``` c++
#include <iostream>
#include <vector>
#include <algorithm>

int N, K, ret;
std::vector<int> v;
std::vector<int> dist;

void solve() {
    // 모든 지점에 집중국을 세울 수 있으면 Ret
    if (K >= N)
        return ;
    // 거리에 대한 배열 만들기
    for (int i = 0; i < v.size() - 1; i++)
        dist.push_back(v[i + 1] - v[i]);
    // 거리 정렬
    std::sort(dist.begin(), dist.end());
    // K - 1개의 큰 거리 연결 지점 삭제
    for (int i = 0; i < K - 1; i++)
        dist.pop_back();
    // 남은 거리 지점 합 구하기
    for (int i = 0; i < dist.size(); i++)
        ret += dist[i];
}

int main(void) {
    // Input
    std::cin >> N >> K;
    for (int i = 0; i < N; i++) {
        int tmp;
        std::cin >> tmp;
        v.push_back(tmp);
    }
    // Solve
    std::sort(v.begin(), v.end());
    solve();
    // Print
    std::cout << ret << std::endl;
}
```
